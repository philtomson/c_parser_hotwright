# Hotstate Machine Simulator

A cycle-accurate simulator for the hotstate machine that can load memory files (.mem) and parameter files (.vh) generated by the C parser, accept input stimulus, and provide detailed output visualization of the hotstate machine's operation.

## Overview

The simulator provides a comprehensive environment for testing and validating hotstate machine designs generated by the C parser, enabling you to verify correctness before hardware deployment.

## Features

- **Cycle-Accurate Simulation**: Models the clock-driven hardware behavior
- **Memory File Loading**: Parses all .mem and .vh files with error checking
- **Input Stimulus**: Text-based format for driving inputs over time
- **Multiple Output Formats**: Console, VCD (waveform), CSV, and JSON
- **Advanced Debugging**: Interactive debugger with single-step, state inspection, watch variables, and manual input control
- **Performance Analysis**: Cycle counts, state transitions, and execution paths
- **Interactive Mode**: Real-time debugging and control

## Building the Simulator

```bash
cd sim/
make
```

This will create the simulator binary at `bin/hotstate_sim`.

## Quick Start

### 1. Generate Test Files

Use the provided example to generate memory files from a C program:

```bash
cd examples/basic_test/
make generate
```

This will compile `simple_example.c` using the C parser and generate:
- `simple_example_vardata.mem`
- `simple_example_switchdata.mem`
- `simple_example_smdata.mem`
- `simple_example_params.vh`

### 2. Run the Simulator

```bash
# Basic console output
make run

# VCD waveform output
make run-vcd

# CSV output for analysis
make run-csv

# Debug mode with detailed output
make debug
```

## Command Line Usage

### Basic Usage

```bash
./bin/hotstate_sim -b <base_path> -s <stimulus_file>
```

### Options

- **Required**:
  - `-b, --base PATH`: Base path for memory files (without extension)

- **Optional**:
  - `-s, --stimulus FILE`: Input stimulus file
  - `-o, --output FILE`: Output file (for non-console formats)
  - `-f, --format FORMAT`: Output format (console|vcd|csv|json) [default: console]
  - `-m, --max-cycles NUM`: Maximum number of cycles to simulate [default: 1000]
  - `-d, --debug`: Enable debug mode
  - `-v, --verbose`: Enable verbose output
  - `-q, --quiet`: Suppress non-error output
  - `--no-realtime`: Disable real-time output
  - `--breakpoint-state N`: Add state breakpoint
  - `--breakpoint-addr ADDR`: Add address breakpoint (hex)
  - `--step NUM`: Step mode: run NUM cycles at a time
  - `--export FILE`: Export results to FILE
  - `--export-format FORMAT`: Export format (csv|json) [default: csv]
  - `-h, --help`: Show help message

### Examples

```bash
# Basic simulation with console output
./bin/hotstate_sim -b examples/basic_test/simple_example -s examples/basic_test/stimulus.txt

# Generate VCD waveform for viewing
./bin/hotstate_sim -b examples/basic_test/simple_example -s examples/basic_test/stimulus.txt -f vcd -o trace.vcd

# Interactive debug mode
./bin/hotstate_sim -b examples/basic_test/switches -d

# Debug mode with breakpoints
./bin/hotstate_sim -b examples/basic_test/switches -d --breakpoint-state 1

# Export results to CSV
./bin/hotstate_sim -b examples/basic_test/simple_example -s examples/basic_test/stimulus.txt --export results.csv
```

## Input Formats

### Stimulus File Format

The stimulus file defines input values over time:

```
# Cycle, Input1, Input2, Input3, ...
# Comments start with #

# Initial state - all inputs low
0, 0, 0, 0

# Cycle 1 - set first input high
1, 1, 0, 0

# Cycle 2 - set second input high
2, 1, 1, 0
```

### Memory Files

The simulator expects the following files generated by the C parser:

- `*_vardata.mem`: Variable data storage (one value per line)
- `*_switchdata.mem`: Switch/case jump address tables
- `*_smdata.mem`: State machine microcode instructions (hexadecimal)
- `*_params.vh`: Parameter definitions and bit widths

## Output Formats

### Console Output

Real-time display of simulation state:
```
Cycle:      0, Addr: 0x0000, Ready: 1, LHS: 0, Fired: 0, States: 00000000, Outputs: [0x00, 0x00], Inputs: [0x00, 0x00]
Cycle:      1, Addr: 0x0001, Ready: 1, LHS: 1, Fired: 1, States: 00000001, Outputs: [0x01, 0x00], Inputs: [0x01, 0x00]
```

### VCD Output

Waveform format compatible with GTKWave and other waveform viewers:
```vcd
$timescale 1ns $end
$scope module hotstate $end
$var wire 1 ! state[0] $end
$var wire 1 " state[1] $end
...
$enddefinitions $end
#0
0!
0"
#1
1!
```

### CSV Output

Tabular data for analysis in spreadsheet applications:
```csv
Cycle,Address,Ready,LHS,Fired,State0,State1,Output0,Output1,Input0,Input1
0,0,1,0,0,0,0,0,0,0,0
1,1,1,1,1,1,0,1,0,1,0
```

### JSON Output

Structured data for programmatic analysis:
```json
{
  "cycle": 0,
  "address": 0,
  "ready": true,
  "lhs": false,
  "fired": false,
  "states": [false, false, false, false],
  "outputs": [0, 0],
  "inputs": [0, 0]
}
```

## Interactive Debug Mode

When using the `-d` flag, the simulator enters interactive debug mode with comprehensive debugging features:

```
Interactive Mode - Type 'help' for commands
sim> help
=== Debugger Commands ===
Simulation Control:
  run              - Run simulation until breakpoint or end
  step [N]         - Step N cycles (default: 1)
  continue         - Continue from breakpoint
  pause            - Pause simulation
  reset            - Reset simulation
  quit             - Exit simulator

Inspection Commands:
  state            - Show current state
  vars             - Show variables/outputs
  microcode        - Show current microcode instruction
  memory [start] [count] - Inspect memory (default: 0, 16)
  stack            - Show call stack
  signals          - Show control signals
  watch            - Evaluate all watch expressions

Breakpoint Commands:
  bp state N       - Add state breakpoint
  bp addr HEX      - Add address breakpoint
  bp clear         - Clear all breakpoints
  bp list          - List breakpoints

Watch Commands:
  watch var N      - Add variable watch
  watch state N    - Add state watch
  watch clear      - Clear all watches
  watch list       - List watches

Manual Control:
  set input N VAL  - Set input N to value VAL
  set var N VAL    - Set variable N to value VAL
  info             - Show current instruction info
  stats            - Show simulation statistics
```

### Debugger Features

**Single-Step Execution:**
```bash
sim> step 1
=== Debug Info - Cycle 0 ===
HotstateModel State: Cycle: 0, Address: 0x0, Ready: 0, LHS: 0, Fired: 0, States: 00000000
```

**State Inspection:**
```bash
sim> state
=== State Inspection ===
Current Address: 0x0
States: 00000000
Ready: 0
```

**Variable Watching:**
```bash
sim> watch var 0
Added watch for variable[0]
sim> watch
=== Watch Evaluation ===
Variable[0] = 0x1
```

**Manual Input Control:**
```bash
sim> set input 0 1
Set input[0] = 0x1
```

**Microcode Inspection:**
```bash
sim> microcode
=== Microcode Inspection ===
Current Address: 0x0
Microcode: 0x00000000
jadr: 0x0
varSel: 0
switchSel: 0
switchAdr: 0
stateCapture: 0
branch: 0
forcedJmp: 0
sub: 0
rtn: 0
```

**Memory Inspection:**
```bash
sim> memory 0 8
=== Memory Inspection ===
Vardata:
  [0] = 0x1
  [1] = 0x1
  [2] = 0x1
  [3] = 0x1
  [4] = 0x0
  [5] = 0x1
  [6] = 0x0
  [7] = 0x1
```

## Debugging Features

### Breakpoints

Set breakpoints to pause simulation when specific conditions are met:

```bash
# Break when state 1 becomes active
./bin/hotstate_sim -b test --breakpoint-state 1

# Break when address 0x0010 is reached
./bin/hotstate_sim -b test --breakpoint-addr 0x0010

# Multiple breakpoints
./bin/hotstate_sim -b test --breakpoint-state 1 --breakpoint-addr 0x0010
```

### Step Mode

Run simulation in steps for detailed analysis:

```bash
# Run 10 cycles at a time
./bin/hotstate_sim -b test --step 10

# Single-step through simulation
./bin/hotstate_sim -b test --step 1
```

## Integration with C Parser

The simulator is designed to work seamlessly with the C parser:

1. **Generate microcode**: Use the C parser to convert C code to hotstate microcode
2. **Load files**: The simulator automatically loads the generated .mem and .vh files
3. **Test stimulus**: Provide input stimulus to test the generated hardware
4. **Analyze results**: Review simulation output to verify correctness

### Workflow Example

```bash
# 1. Generate microcode from C code
cd ../../
./c_parser examples/basic_test/simple_example.c --hotstate

# 2. Run simulation
cd sim/
./bin/hotstate_sim -b ../examples/basic_test/simple_example -s examples/basic_test/stimulus.txt

# 3. Analyze results
# View console output, VCD waveforms, or CSV data
```

## Directory Structure

```
sim/
├── src/                    # Source code
│   ├── main.cpp           # Command line interface
│   ├── simulator.cpp      # Core simulator engine
│   ├── hotstate_model.cpp # Hotstate machine implementation
│   ├── memory_loader.cpp  # Memory file parsing
│   ├── stimulus_parser.cpp # Input stimulus handling
│   ├── output_logger.cpp  # Output and trace handling
│   └── utils.cpp          # Common utilities
├── include/               # Header files
├── examples/              # Example test cases
│   └── basic_test/
│       ├── simple_example.c
│       ├── stimulus.txt
│       └── Makefile
├── bin/                   # Built binaries
├── obj/                   # Object files
└── Makefile              # Build configuration
```

## Troubleshooting

### Common Issues

1. **"File not found" errors**: Ensure the base path is correct and memory files exist
2. **"Invalid parameter" errors**: Check that all memory files are compatible
3. **Simulation doesn't start**: Verify the stimulus file format is correct
4. **No output**: Check that the output file path is writable

### Debug Tips

1. Use `-v` for verbose output to see what's happening
2. Use `-d` for debug mode to get detailed information
3. Check the generated memory files with `make show` in the example directory
4. Start with a simple stimulus file and gradually increase complexity

### Performance

- Use CSV or JSON output for large simulations (faster than console)
- Disable real-time output with `--no-realtime` for batch processing
- Use appropriate max-cycles limit to prevent infinite loops

## Contributing

The simulator is designed to be extensible. Key areas for enhancement:

1. **Additional output formats**: Add support for other waveform formats
2. **Performance optimization**: Improve simulation speed for large designs
3. **GUI interface**: Add graphical debugging interface
4. **Analysis tools**: Add more sophisticated analysis features

## License

This simulator is part of the hotstate C parser project and follows the same licensing terms.