# Hotstate .mem File Compatibility Analysis and Proposed Changes for c_parser

This document outlines the discrepancies between Hotstate's `.mem` file generation and `c_parser`'s current implementation, along with proposed changes to ensure compatibility.

## Hotstate .mem Files: Meaning and Generation

In Hotstate, the `.mem` files serve as memory initialization files for the Verilog hardware. They are generated by the `PrintVivado` function in `/home/phil/devel/FPGA/hotstate/src/output.c`.

1.  **`<name>_smdata.mem` (State Machine Data):**
    *   **Meaning:** This file contains the packed microcode instructions for the Hotstate state machine. Each line is a 64-bit hexadecimal word representing a single instruction.
    *   **Generation:** The fields of the microcode instruction (`state`, `mask`, `jadr`, `varSel`, `timerSel`, `timerLd`, `switch_sel`, `switch_adr`, `state_capture`, `var_or_timer`, `branch`, `forced_jmp`, `sub`, `rtn`) are packed into a `uint64_t` in a specific order (LSB to MSB) with predefined bit-widths. This packing occurs in lines 97-110 of `/home/phil/devel/FPGA/hotstate/src/output.c`.

2.  **`<name>_vardata.mem` (Variable Data / Uber LUT Data):**
    *   **Meaning:** This file represents the "Uber LUT" (Look-Up Table) for variable selection. It's essentially a flattened truth table that maps input variable combinations to specific outcomes. Each line typically contains a single hexadecimal value (likely 0 or 1, representing a bit in the LUT).
    *   **Generation:** Hotstate writes the `vardata` array elements to this file (line 134 in `/home/phil/devel/FPGA/hotstate/src/output.c`).

3.  **`<name>_switchdata.mem` (Switch Data):**
    *   **Meaning:** This file contains jump addresses for `switch` statements. It acts as a lookup table where the switch expression's value directly maps to an address in the microcode (`_smdata.mem`).
    *   **Generation:** Hotstate writes the `switchmem` array elements to this file (line 145 in `/home/phil/devel/FPGA/hotstate/src/output.c`).

## Discrepancies between Hotstate and `c_parser`

| Feature          | Hotstate (`output.c`)                                             | `c_parser` (`microcode_output.c`)                                     | Discrepancy                                                                                                                                     |
| :--------------- | :---------------------------------------------------------------- | :-------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------- |
| `_smdata.mem`    | Fields packed LSB to MSB: `state`, `mask`, `jadr`, `varSel`, `timerSel`, `timerLd`, `switch_sel`, `switch_adr`, `state_capture`, `var_or_timer`, `branch`, `forced_jmp`, `sub`, `rtn`. Fixed/derived bit-widths. | Fields packed LSB to MSB: `rtn`, `sub`, `forced_jmp`, `branch`, `var_or_timer`, `state_capture`, `switch_adr`, `switch_sel`, `timerLd`, `timerSel`, `varSel`, `jadr`, `mask`, `state`. Dynamic bit-widths. | **Packing Order:** Completely different. **Bit Widths:** Different calculation methods, potentially different final widths. **Instruction Granularity:** Hotstate combines multiple state assignments within a single C statement into one microcode instruction, whereas `c_parser` generates a separate microcode instruction for each individual state assignment. This leads to a different number of instructions and different packed values for combined assignments. |
| `_vardata.mem`   | `vardata` array. Each element is printed as `%x\n`. Likely single-bit values. Used as `uberLUTdata` later. | Prints `i` (loop counter) as `%02x\n`. Placeholder/incorrect data.    | **Content:** `c_parser` generates incorrect placeholder data.                                                                                    |
| `_switchdata.mem`| `switchmem` array. Each element printed as `%x\n`. Stores jump addresses for switch cases. | Not generated. `c_parser` has no equivalent for this file.           | **Existence:** `c_parser` does not generate this file, which is crucial for Hotstate's switch handling.                                     |

## Proposed Changes to `c_parser`

### Note on `print_compact_microcode_table` and `.mem` file generation:

The `c_parser`'s `print_compact_microcode_table` (which is commented out as `print_hotstate_microcode_table` in `microcode_output.c`) is designed for human-readable output of microcode fields. It does **not** perform the bit-packing into a single `uint64_t` word required for `.mem` files. The `generate_smdata_mem_file` function already correctly utilizes `pack_mcode_instruction` to produce the packed `uint64_t` words needed for `_smdata.mem`. Therefore, `print_compact_microcode_table` is not directly adaptable for generating the `.mem` files themselves. The primary task for `_smdata.mem` compatibility remains the modification of `pack_mcode_instruction` to match Hotstate's specific bit-packing order and widths.

---

To align `c_parser`'s `.mem` file generation with Hotstate's, the following modifications are required:

1.  **Generate Initial State/Mask Instruction (Address 0):**
    *   **Discrepancy:** Hotstate generates an initial microcode instruction at Address 0 whose `state` and `mask` fields are derived from the initial values of global state variables in the C code. For example, if `bool LED2 = 1;` then the initial `state` bit for `LED2` will be set. `c_parser` currently does not generate such an instruction; its first instruction is derived from the first actual SSA assignment in the C code.
    *   **Proposed Change:** `c_parser` needs to insert a special initial microcode instruction at Address 0. This instruction's `state` field should be calculated by OR-ing the initial values of all global state variables (shifted to their corresponding bit positions). The `mask` field should be set to mask all state bits `((1 << mc->hw_ctx->state_count) - 1)`. This instruction should also have `forced_jmp = 1` to proceed to the next instruction. This will ensure `c_parser`'s output matches Hotstate's initial state and mask. All subsequent microcode instructions will have their addresses incremented by 1.

3.  **Rewrite `pack_mcode_instruction` in [`microcode_output.c`](microcode_output.c):**
    *   **Order:** The bit packing order within the `packed_word` must be changed to match Hotstate's: `state` (LSB), `mask`, `jadr`, `varSel`, `timerSel`, `timerLd`, `switch_sel`, `switch_adr`, `state_capture`, `var_or_timer`, `branch`, `forced_jmp`, `sub`, `rtn` (MSB). Our analysis indicates the order in `c_parser` already aligns with Hotstate's.
    *   **Bit-widths:** The `calculate_bit_width` function in `c_parser` needs to be carefully reviewed and adjusted to ensure that the calculated bit-widths for each microcode field precisely match the widths used by Hotstate. This involves:
        *   Dynamically determining `jadr_width` based on the maximum jump address, rather than a fixed value.
        *   Harmonizing `varSel`, `timerSel`, `timerLd`, and `switch_sel` width calculations with Hotstate's derivation from relevant global parameters (e.g., `gvarSel`, `gTimers`, `gSwitches`).
    *   **Multi-Word Instructions:** If the total combined bit-width of all microcode fields exceeds 64 bits, the `pack_mcode_instruction` function will need to be modified to pack the instruction across multiple `uint64_t` words. This will require the function to return an array of `uint64_t` values (or take a `uint64_t*` buffer) and `generate_smdata_mem_file` to write these multiple words to the `.mem` file. The Verilog side will also need to be adapted to read and concatenate these multiple words.

4.  **Implement `_switchdata.mem` generation in [`microcode_output.c`](microcode_output.c):**
    *   A new function, similar to `generate_smdata_mem_file`, needs to be added to create the `_switchdata.mem` file.
    *   This function will require access to the switch jump addresses. In `c_parser`, these addresses are available within the `MCode` structure (specifically the `jadr` field) and the `CompactMicrocode` structure, which are generated when `--microcode-hs` is specified. The `switch_sel` and `switch_adr` fields of the `MCode` structure are also crucial for identifying switch-related instructions and their corresponding jump addresses.
    *   The generation logic will need to iterate through the microcode instructions, identify those related to switches, and extract the relevant jump addresses to populate the `_switchdata.mem` file in the correct format. This might involve creating a dedicated data structure to store the switch-case mappings during the microcode generation phase.

4.  **Correct `_vardata.mem` generation (Uber LUT Population)**

    The `_vardata.mem` file in Hotstate represents a pre-computed "Uber LUT" (Look-Up Table) for conditional expressions involving input variables. This LUT flattens complex boolean logic into a simple truth table, where each entry corresponds to a unique combination of input variable values and provides the expression's outcome. Currently, `c_parser` generates a placeholder `_vardata.mem` filled with zeros.

    **Current State in Hotstate (based on source analysis):**
    *   The `vardata` array is populated in `hotstate/src/exprList.c` via assignments like `vardata[i+vardata_num] = (unsigned char) (expr->simop->LUT[i]);`.
    *   This implies that `Hotstate` pre-computes the truth table for each relevant expression and stores it in `expr->simop->LUT`.
    *   The `vardata_num` suggests that different expressions might contribute to different sections of the global `vardata` array.
    *   The `_vardata.mem` file is only generated if `numVars` (total number of input variables requiring LUT processing) is greater than 0.
    *   Hotstate's `EvalOp` in `analysis.c` demonstrates how LUTs are combined for complex expressions (e.g., `simop->LUT[i] = EvalOp(simop->lhs->LUT[i],simop->op,simop->rhs->LUT[i]);`). This is a key part of the "Expression Evaluator/Simulator".

    **Proposed Plan for `c_parser`:**

    Implementing the full "Uber LUT" generation is a complex task, requiring a new analysis pass to evaluate conditional expressions across all input combinations. This can be broken down into the following sub-tasks:

    1.  **Identify and Collect Input-Dependent Conditional Expressions**:
        *   **Goal**: Traverse the AST (e.g., in `ast_to_microcode.c` or a new pass) to identify all `NODE_IF`, `NODE_WHILE`, `NODE_FOR` conditions, and `NODE_SWITCH` expressions that depend on `HW_VAR_INPUT` variables.
        *   **Details**: For each identified expression, determine the set of `HW_VAR_INPUT` variables it explicitly uses.

    2.  **Develop an Expression Evaluator/Simulator**:
        *   **Goal**: Create a component that can evaluate a given boolean expression (derived from the AST) for all possible combinations of its dependent `HW_VAR_INPUT` variables.
        *   **Details**: This component would function similarly to Hotstate's `EvalOp` and related logic. It would:
            *   Generate "eigenLUTs" for individual input variables.
            *   Recursively evaluate complex expressions by combining the LUTs of their sub-expressions based on operators (AND, OR, NOT, etc.).
            *   For each combination of input variable values, the evaluator would produce a single bit (0 or 1) representing the expression's outcome, effectively building the `simop->LUT` for each expression.

    3.  **Populate `CompactMicrocode.vardata` (New Member)**:
        *   **Goal**: Create a new member in `CompactMicrocode` (e.g., `uint8_t* vardata_lut;` and `int vardata_lut_size;`) to store the generated Uber LUT.
        *   **Details**: During the microcode generation pass (or a preceding pass), after expressions are identified and evaluated:
            *   Allocate `vardata_lut` with the appropriate size (`mc->hw_ctx->input_count * (1 << mc->hw_ctx->input_count)` or similar, based on the actual number of input variables that need LUT processing).
            *   Each element in `vardata_lut` will store a single bit (0 or 1) representing the expression's outcome for a given input combination. While `uint8_t*` (or `unsigned char*`, as used in Hotstate) is used to store these single-bit values, this might lead to memory inefficiency if not packed. However, for direct compatibility and simpler access, storing one bit per byte is a common approach. Further optimization for memory packing (e.g., into `uint64_t` arrays) can be considered as a future refinement.
            *   Populate `vardata_lut` with the results from the expression evaluator. The mapping from input combinations to array indices needs to be consistent with Hotstate's flattened LUT (e.g., handling `vardata_num` offsets if multiple expressions contribute to the same global LUT).

    4.  **Refine `generate_vardata_mem_file`**:
        *   **Goal**: Modify `generate_vardata_mem_file` in `microcode_output.c` to read from the newly populated `mc->vardata_lut` instead of generating placeholder zeros.
        *   **Details**: Ensure the output format (`%x\n`) and size align with Hotstate's `_vardata.mem` output.

    **Dependencies**:
    *   Accurate identification and tracking of `HW_VAR_INPUT` variables and their initial values.
    *   A clear understanding of Hotstate's exact "Uber LUT" generation algorithm if precise replication is desired.

    **Complexity**: High. This involves implementing a significant new analysis and evaluation capability within `c_parser`.

5.  **Enable `.mem` file generation in [`main.c`](main.c):**
    *   The commented-out code block in [`main.c`](main.c) (lines 261-297) that calls `generate_all_output_files` needs to be uncommented and activated. Alternatively, a new command-line argument could be introduced to explicitly trigger the generation of these `.mem` files, independent of other outputs.

## Step-by-Step _vardata.mem File Creation Process

The creation of the `_vardata.mem` file involves several distinct phases within the `c_parser`, starting from the input C file and culminating in the memory file.

### 1. Parsing the Input C File

*   **Input:** A C source file (e.g., [`examples/simple/simple.c`](examples/simple/simple.c)).
*   **Process:** The `c_parser` uses a [`lexer.c`](lexer.c) to convert the C source code into a stream of tokens (e.g., `if`, `(`, `a0`, `==`, `0`, `&&`, `a1`, `==`, `1`, `)`). These tokens are then fed to a [`parser.c`](parser.c), which builds an Abstract Syntax Tree (AST). The AST is a hierarchical representation of the program's structure, where each node represents a construct in the source code (e.g., a function definition, an `if` statement, a binary operation).

### 2. Hardware Analysis and Context Building

*   **Input:** The generated AST.
*   **Process:** The [`hw_analyzer.c`](hw_analyzer.c) module traverses the AST to identify and categorize hardware-related variables.
    *   It distinguishes between "state variables" (global variables with initializers, typically representing outputs like `led0`, `led1`) and "input variables" (global variables without initializers, representing inputs like `a0`, `a1`, `a2`).
    *   For each identified input variable, it assigns a unique sequential `input_number` (e.g., `a0` becomes `input0`, `a1` becomes `input1`, etc.).
    *   All this information, including the total count of input variables (`input_count`), is stored in a `HardwareContext` structure. This `HardwareContext` is crucial because the size of the Lookup Tables (LUTs) in `_vardata.mem` depends on the total number of input variables.

### 3. AST to Microcode Conversion and Conditional Expression Collection

*   **Input:** The AST and the `HardwareContext`.
*   **Process:** The core conversion happens in [`ast_to_microcode.c`](ast_to_microcode.c). This module traverses the AST to translate the C code into a compact microcode representation.
    *   During this traversal, specifically when it encounters conditional expressions (e.g., conditions in `if` statements, `while` loops, or `switch` expressions), it collects them.
    *   For each unique conditional expression, it creates a `ConditionalExpressionInfo` structure. This structure stores a pointer to the AST node of the expression and a unique `varsel_id`. The `varsel_id` is a sequential identifier assigned using `mc->var_sel_counter`.
    *   These `ConditionalExpressionInfo` structs are stored in the `mc->conditional_expressions` array within the `CompactMicrocode` structure.

### 4. Expression Evaluation and Individual LUT Generation

*   **Input:** The collected `ConditionalExpressionInfo` structs and the `HardwareContext`.
*   **Process:** After the entire AST has been traversed and all conditional expressions have been collected, the `c_parser` enters the expression evaluation phase, primarily handled by [`expression_evaluator.c`](expression_evaluator.c).
    *   For each `ConditionalExpressionInfo` in the `mc->conditional_expressions` array, the `create_simulated_expression` function builds a `SimulatedExpression` tree from its AST node. This tree represents the expression in a form suitable for simulation.
    *   Then, `eval_simulated_expression` is called for each `SimulatedExpression`. This function performs the crucial task of generating a "truth table" or Lookup Table (LUT) for that specific conditional expression.
        *   It determines the total number of input variables (`num_total_input_vars`) from the `HardwareContext`.
        *   It then iterates through all possible combinations of these input variables (from 0 to `2^num_total_input_vars - 1`).
        *   For each input combination, it evaluates the `SimulatedExpression` to produce a single-bit output (0 or 1). This output is stored in the `sim_expr->LUT` array.
        *   The `sim_expr->LUT` effectively maps every possible input combination to the output of that specific conditional expression.

### 5. Aggregation of LUTs into `vardata_lut`

*   **Input:** The individual `sim_expr->LUT`s generated in the previous step.
*   **Process:** Back in [`ast_to_microcode.c`](ast_to_microcode.c), after all individual expressions have been evaluated and their `sim_expr->LUT`s populated:
    *   A single, large `mc->vardata_lut` array is allocated. Its total size is `mc->conditional_expression_count * (2^num_total_input_vars)`.
    *   The contents of each individual `sim_expr->LUT` are then copied into `mc->vardata_lut`. The position where each `sim_expr->LUT` is copied is determined by its `varsel_id`, effectively creating blocks of LUT data within the `vardata_lut` array. This aggregated `vardata_lut` holds the truth tables for all conditional expressions in the program.

### 6. Writing the `_vardata.mem` File

*   **Input:** The populated `mc->vardata_lut` and its size (`mc->vardata_lut_size`).
*   **Process:** The final step is handled by [`microcode_output.c`](microcode_output.c).
    *   The `generate_vardata_mem_file` function is called, receiving the `CompactMicrocode` structure.
    *   This function opens the `_vardata.mem` file for writing.
    *   It then iterates through `mc->vardata_lut` and writes each byte (representing a single bit of the LUT output) as a separate line in the `.mem` file. This is why the `_vardata.mem` file contains a long list of 0s and 1s, representing the combined truth tables of all conditional expressions.

```mermaid
graph TD
    A[C Source File] --> B{Lexer & Parser};
    B --> C[Abstract Syntax Tree (AST)];
    C --> D[Hardware Analyzer (hw_analyzer.c)];
    D --> E[HardwareContext (Input Variables, etc.)];
    C --> F[AST to Microcode Converter (ast_to_microcode.c)];
    F --> G[Collected Conditional Expressions (in CompactMicrocode)];
    G & E --> H[Expression Evaluator (expression_evaluator.c)];
    H --> I[Individual SimulatedExpression LUTs];
    I & E --> J[LUT Aggregation (in ast_to_microcode.c)];
    J --> K[Final vardata_lut in CompactMicrocode];
    K --> L[Microcode Output Generator (microcode_output.c)];
    L --> M[_vardata.mem File];
```