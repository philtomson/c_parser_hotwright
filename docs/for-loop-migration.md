# For Loop Microcode Generation Migration Plan

This document details the implementation of `for` loop microcode generation within `ast_to_microcode.c`, including the integration of `process_for_loop` and the handling of `break` and `continue` statements using the `LoopSwitchContext` stack. It also covers the migration of timer counting from a global variable to the `CompactMicrocode` struct.

## Objectives

*   Implement proper microcode generation for `for` loops.
*   Integrate `for` loop processing with the `LoopSwitchContext` stack for correct `break` and `continue` handling.
*   Migrate timer counting from the global `gTimers` variable to `mc->timer_count` within the `CompactMicrocode` structure.

## Implementation Details

### 1. Remove Global `gTimers`

The global `gTimers` variable is no longer needed as timer counting will be managed within the `CompactMicrocode` struct.

**Changes in `ast_to_microcode.c`:**

*   Remove the declaration:
    ```c
    // Remove from ast_to_microcode.c (near line 18)
    static int gTimers = 0;
    ```
*   Remove the initialization:
    ```c
    // Remove from ast_to_microcode.c (within ast_to_compact_microcode, near line 57)
    gTimers = 0;
    ```

### 2. Integrate `process_for_loop`

A new static function `process_for_loop` will be introduced to handle the specific logic for `for` loop microcode generation.

#### A. Forward Declaration

Add the forward declaration for `process_for_loop` alongside other static function declarations in `ast_to_microcode.c`:

```c
// In ast_to_microcode.c (near other static forward declarations)
static void process_for_loop(CompactMicrocode* mc, ForNode* for_node, int* addr);
```

#### B. `process_for_loop` Function Implementation

This function will generate microcode for the initializer, condition, body, and update sections of a `for` loop. It will also manage the `LoopSwitchContext` stack.

```c
// Add this function to ast_to_microcode.c
static void process_for_loop(CompactMicrocode* mc, ForNode* for_node, int* addr) {
    // --- Phase 1: Process Initializer ---
    // Generate microcode for the for loop's initialization statement.
    if (for_node->init) {
        process_statement(mc, for_node->init, addr);
    }

    // --- Phase 2: Set up Loop Context ---
    // The loop_header_addr is the microcode address where the for loop's condition check begins.
    int loop_header_addr = *addr; 

    // Estimate break_target: This is the address immediately after the entire for loop construct.
    // It's an estimate based on the total microcode instructions generated by the for loop.
    // A more precise approach for complex loops might involve a fixup mechanism.
    int estimated_break_target = *addr + count_statements((Node*)for_node);

    // The continue_target for a for loop points to its update expression.
    // This is initially an estimate, and will be fixed up after the body is processed.
    int estimated_update_addr = *addr + (for_node->body ? count_statements(for_node->body) : 0) + 1; // +1 for the jump back to header

    // Push the current for loop's context onto the stack.
    // This context will be used by any nested 'break' or 'continue' statements.
    LoopSwitchContext current_loop_context = {
        .loop_type = NODE_FOR,
        .continue_target = estimated_update_addr, // 'continue' jumps to update
        .break_target = estimated_break_target    // 'break' jumps to after the loop
    };
    push_context(mc, current_loop_context);

    // --- Phase 3: Generate Loop Condition ---
    // Generate microcode to evaluate the for loop's condition.
    // If the condition is false, execution branches to the estimated_break_target.
    char* condition_label = NULL;
    if (for_node->condition) {
        condition_label = create_condition_label(for_node->condition);
        uint32_t cond_word = encode_compact_instruction(0, 0, estimated_break_target, ++gvarSel, 0, 0, 0, 0, 1, 0, 0);
        add_compact_instruction(mc, cond_word, condition_label);
        mc->branch_instructions++;
        (*addr)++;
        free(condition_label); // Free the label after use
    } else {
        // Handle infinite for loops (for (;;)). No condition means it always "continues".
        // A NOP instruction is added to maintain address consistency for the loop header.
        add_compact_instruction(mc, encode_compact_instruction(0,0,0,0,0,0,0,0,0,0,0), "for_header_nop");
        (*addr)++;
    }

    // --- Phase 4: Process Loop Body ---
    // Recursively generate microcode for the statements within the for loop's body.
    if (for_node->body) {
        process_statement(mc, for_node->body, addr);
    }

    // --- Phase 5: Process Update Statement ---
    // Capture the actual microcode address of the update section.
    // This is the true target for 'continue' statements.
    int update_section_addr = *addr;
    // Fix up the continue_target in the context currently on top of the stack.
    // The initial push used an estimate; now we have the precise address.
    mc->loop_switch_stack[mc->stack_ptr - 1].continue_target = update_section_addr;

    // Generate microcode for the for loop's update expression.
    if (for_node->update) {
        process_expression(mc, for_node->update, addr); // Assuming process_expression handles it
    }

    // --- Phase 6: Jump back to Loop Header ---
    // Generate an unconditional jump from the end of the update section back to the loop's condition (header).
    uint32_t jump_back_word = encode_compact_instruction(0, 0, loop_header_addr, 0, 0, 0, 0, 0, 0, 1, 0);
    add_compact_instruction(mc, jump_back_word, "for_loop_jump_back");
    mc->jump_instructions++;
    (*addr)++;

    // --- Phase 7: Pop Loop Context ---
    // The for loop has been fully processed, so its context is removed from the stack.
    pop_context(mc);
}
```

### 3. Update `process_statement`

The `process_statement` function will be modified to include a `NODE_FOR` case. The `NODE_WHILE`, `NODE_BREAK`, `NODE_CONTINUE`, and `NODE_SWITCH` cases will also be updated to correctly use the `LoopSwitchContext` stack.

```c
// In ast_to_microcode.c (within process_statement function)
static void process_statement(CompactMicrocode* mc, Node* stmt, int* addr) {
    if (!stmt) return;
    
    switch (stmt->type) {
        case NODE_WHILE: {
            WhileNode* while_node = (WhileNode*)stmt;
            
            // Determine continue_target (address of the while loop header) and break_target (address after the loop)
            int while_loop_start_addr = *addr; 
            int estimated_break_target = *addr + count_statements(while_node);

            // Create and push the loop context onto the stack
            LoopSwitchContext current_loop_context = {
                .loop_type = NODE_WHILE,
                .continue_target = while_loop_start_addr,
                .break_target = estimated_break_target
            };
            push_context(mc, current_loop_context);
            
            // Generate the while loop header instruction (jumps to break_target if condition is false)
            uint32_t while_word = encode_compact_instruction(0, 0, current_loop_context.break_target, 0, 0, 0, 0, 0, 1, 0, 0);
            add_compact_instruction(mc, while_word, "while (1) {");
            (*addr)++;
            
            // Process while body statements
            if (while_node->body) {
                if (while_node->body->type == NODE_BLOCK) {
                    BlockNode* block = (BlockNode*)while_node->body;
                    if (block->statements) {
                        for (int i = 0; i < block->statements->count; i++) {
                            process_statement(mc, block->statements->items[i], addr);
                        }
                    }
                } else {
                    process_statement(mc, while_node->body, addr);
                }
            }
            
            // Add the jump back to the loop header for the next iteration
            uint32_t jump_word = encode_compact_instruction(0, 0, current_loop_context.continue_target, 0, 0, 0, 0, 0, 0, 1, 0);
            add_compact_instruction(mc, jump_word, "}");
            mc->jump_instructions++;
            (*addr)++;
            
            // Pop the context from the stack
            pop_context(mc);
            break;
        }
        
        case NODE_FOR: {
            ForNode* for_node = (ForNode*)stmt;
            // Increment timer_count for each for loop encountered
            mc->timer_count++;
            process_for_loop(mc, for_node, addr); // Delegate to the new for loop processing function
            break;
        }
        
        case NODE_IF: {
            IfNode* if_node = (IfNode*)stmt;
            
            // Determine the condition and create appropriate label
            char* condition_label = create_condition_label(if_node->condition);
            
            // Calculate jump address based on statement structure
            int jump_addr = calculate_jump_address(mc, if_node, *addr);
            
            uint32_t if_word = encode_compact_instruction(0, 0, jump_addr, ++gvarSel, 0, 0, 0, 0, 1, 0, 0);
            add_compact_instruction(mc, if_word, condition_label);
            mc->branch_instructions++;
            (*addr)++;
            
            // Process then branch
            if (if_node->then_branch) {
                process_statement(mc, if_node->then_branch, addr);
            }
            
            // Process else branch if present
            if (if_node->else_branch) {
                // Always generate an "else" instruction first, regardless of whether it's else-if or else-block
                // Calculate the jump address for the else (should jump past the entire if-else chain)
                int else_jump_addr = calculate_else_jump_address(mc, if_node, *addr);
                uint32_t else_word = encode_compact_instruction(0, 0, else_jump_addr, 0, 0, 0, 0, 0, 0, 1, 0);
                add_compact_instruction(mc, else_word, "else");
                mc->jump_instructions++;
                (*addr)++;
                
                // Then process the else branch (whether it's else-if or else-block)
                process_statement(mc, if_node->else_branch, addr);
            }
            
            free(condition_label);
            break;
        }
        
        case NODE_ASSIGNMENT: {
            AssignmentNode* assign = (AssignmentNode*)stmt;
            process_assignment(mc, assign, addr);
            break;
        }
        
        case NODE_EXPRESSION_STATEMENT: {
            ExpressionStatementNode* expr_stmt = (ExpressionStatementNode*)stmt;
            process_expression_statement(mc, expr_stmt, addr);
            break;
        }
        
        case NODE_BLOCK: {
            BlockNode* block = (BlockNode*)stmt;
            for (int i = 0; i < block->statements->count; i++) {
                process_statement(mc, block->statements->items[i], addr);
            }
            break;
        }
        
        case NODE_SWITCH: {
            SwitchNode* switch_node = (SwitchNode*)stmt;
            // For switch, we also push a context to handle 'break'
            // The break_target for a switch is the address after the switch statement.
            int switch_break_target = *addr + count_statements((Node*)switch_node);
            LoopSwitchContext current_switch_context = {
                .loop_type = NODE_SWITCH, // Indicate it's a switch
                .continue_target = -1,    // Continue is not applicable for switch
                .break_target = switch_break_target
            };
            push_context(mc, current_switch_context);

            process_switch_statement(mc, switch_node, addr);
            
            pop_context(mc); // Pop the switch context after processing
            break;
        }
        
        case NODE_BREAK: {
            // Peek the current loop/switch context
            LoopSwitchContext current_context = peek_context(mc);
            if (current_context.break_target == -1) { // Error handling for invalid context
                fprintf(stderr, "Error: 'break' statement used outside of a loop or switch context.\n");
                return;
            }
            // Optional: Use loop_type for more specific validation or behavior
            if (current_context.loop_type != NODE_WHILE && current_context.loop_type != NODE_FOR && current_context.loop_type != NODE_SWITCH) {
                fprintf(stderr, "Warning: 'break' used outside of a loop or switch context (type: %d).\n", current_context.loop_type);
            }

            // Generate a jump instruction to the break_target
            uint32_t break_word = encode_compact_instruction(0, 0, current_context.break_target, 0, 0, 0, 0, 0, 0, 1, 0);
            add_compact_instruction(mc, break_word, "break;");
            mc->jump_instructions++;
            (*addr)++;
            break;
        }
        
        case NODE_CONTINUE: {
            // Peek the current loop/switch context
            LoopSwitchContext current_context = peek_context(mc);
            if (current_context.continue_target == -1) { // Error handling for invalid context
                fprintf(stderr, "Error: 'continue' statement used outside of a loop context.\n");
                return; 
            }
            // Optional: Use loop_type for more specific validation or behavior
            if (current_context.loop_type != NODE_WHILE && current_context.loop_type != NODE_FOR) {
                fprintf(stderr, "Warning: 'continue' used outside of a loop context (type: %d).\n", current_context.loop_type);
            }

            // Generate a jump instruction to the continue_target
            uint32_t continue_word = encode_compact_instruction(0, 0, current_context.continue_target, 0, 0, 0, 0, 0, 0, 1, 0);
            add_compact_instruction(mc, continue_word, "continue;");
            mc->jump_instructions++;
            (*addr)++;
            break;
        }
        
        default:
            // Skip other statement types for now
            break;
    }
}
```

### 4. Update `count_statements`

The `count_statements` function needs to correctly estimate the microcode instructions generated by a `for` loop.

```c
// In ast_to_microcode.c (within count_statements function)
case NODE_FOR: {
    ForNode* for_node = (ForNode*)stmt;
    int count = 0;
    // Initializer
    if (for_node->init) {
        count += count_statements(for_node->init);
    }
    // Condition (at least one instruction for the branch)
    count += 1; // For the condition evaluation and branch instruction
    // Body
    if (for_node->body) {
        count += count_statements(for_node->body);
    }
    // Update
    if (for_node->update) {
        count += count_statements(for_node->update);
    }
    // Jump back to header
    count += 1; // For the unconditional jump back to the loop header
    return count;
}