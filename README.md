# C Parser with support for Hotwright microcode generation

A recursive descent C parser that builds an Abstract Syntax Tree (AST), generates Control Flow Graphs (CFG), and generates hardware microcode and Verilog HDL for FPGA implementation.

## Features

### Parser Features
- **Lexical Analysis**: Tokenizes C source code with line/column tracking
- **Recursive Descent Parsing**: Builds AST from tokens
- **Enhanced Error Reporting**: Precise error messages with line and column numbers
- **Supported Language Constructs**:
  - Variable declarations (`int x = 5;`, `bool flag = true;`)
  - Arrays and initialization lists
  - **C23 `_BitInt` Types**: Bit-precise integers with indexing (`_BitInt(8) x = {1,0,1,1,0,0,1,0};`)
  - Arithmetic expressions with proper precedence
  - Control structures:
    - If-else statements
    - While loops
    - For loops
    - Switch statements (partial)
  - Functions:
    - Function definitions with parameters
    - Function calls with arguments
    - Return statements
  - Comments (single-line `//` and multi-line `/* */`)
  - Break statements

### Control Flow Graph (CFG) Features
- **AST to CFG Conversion**: Transforms the AST into a graph-based representation
- **SSA-Style Instructions**: Uses variable versioning for analysis
- **Visualization**: Generates DOT files for Graphviz rendering
- **Foundation for Optimization**: Ready for SSA form and optimization passes

### Hardware Synthesis Features
- **Hardware Analysis**: Detects state variables and input variables from C code
- **Microcode Generation**: Produces hotstate-compatible microcode for FPGA implementation
- **Verilog HDL Generation**: Creates synthesizable Verilog modules and testbenches
- **Memory File Generation**: Outputs .mem files for FPGA synthesis tools

## Building

```bash
cd src
make clean
make all
```

This builds:
- `c_parser` - Main parser executable
- `test_cfg` - CFG test suite

## Usage

### Basic Parser Usage

```bash
# Parse a file
./c_parser test/test_simple.c

# Parse default example
./c_parser
```

### CFG Generation with DOT Output

```bash
# Generate CFG and DOT file for visualization
./c_parser --dot test/test_simple.c

# Enable debug output to see detailed parsing information
./c_parser --debug --dot test/test_simple.c

# Run CFG tests
./test_cfg

# Generate visualization graphs
make graphs
```

This creates DOT files and PNG images showing the control flow graphs.

### Hardware Synthesis Usage

```bash
# Analyze hardware constructs (state and input variables)
./c_parser --hardware ../test/test_hardware_local.c

# Generate hotstate-compatible microcode
./c_parser --microcode-hs ../test/test_hardware_local.c

# Generate Verilog HDL module
./c_parser --verilog ../test/test_hardware_local.c

# Generate Verilog testbench
./c_parser --testbench ../test/test_hardware_local.c

# Generate complete HDL package (module, testbench, stimulus, makefile)
./c_parser --all-hdl ../test/test_hardware_local.c

# Combine multiple options
./c_parser --hardware --microcode-hs --verilog test/test_hardware_local.c
```

#### Hardware Variable Patterns

The parser recognizes hardware patterns in C code:

```c
int main() {
    // State variables (outputs) - boolean with initialization
    bool LED0 = 0;  // Detected as state0
    bool LED1 = 0;  // Detected as state1
    bool LED2 = 1;  // Detected as state2
    
    // Input variables - boolean without initialization
    bool a0, a1, a2;  // Detected as input0, input1, input2
    
    // Hardware logic
    if (a0) {
        LED0 = 1;
    }
    
    if (a1) {
        LED1 = 1;
    }
    
    return 0;
}
```

#### Generated Output Files

- **`module_template.v`** - Synthesizable Verilog module
- **`module_tb.v`** - Verilog testbench
- **`module_smdata.mem`** - Microcode memory file
- **`module_vardata.mem`** - Variable mapping file
- **`user.v`** - User-editable stimulus file
- **`Makefile.sim`** - Simulation makefile

## Simulator

A cycle-accurate simulator for the hotstate machine that can load memory files (.mem) and parameter files (.vh) generated by the C parser, accept input stimulus, and provide detailed output visualization of the hotstate machine's operation.

### Simulator Features

- **Cycle-Accurate Simulation**: Models the clock-driven hardware behavior
- **Memory File Loading**: Parses all .mem and .vh files with error checking
- **Input Stimulus**: Text-based format for driving inputs over time
- **Multiple Output Formats**: Console, VCD (waveform), CSV, and JSON
- **Advanced Debugging**: Interactive debugger with single-step, state inspection, watch variables, and manual input control
- **Performance Analysis**: Cycle counts, state transitions, and execution paths
- **Interactive Mode**: Real-time debugging and control

### Building the Simulator

```bash
cd sim/
make
```

This will create the simulator binary at `bin/hotstate_sim`.

### Simulator Usage

#### Basic Usage

```bash
./bin/hotstate_sim -b <base_path> -s <stimulus_file>
```

#### Command Line Options

- **Required**:
  - `-b, --base PATH`: Base path for memory files (without extension)

- **Optional**:
  - `-s, --stimulus FILE`: Input stimulus file
  - `-o, --output FILE`: Output file (for non-console formats)
  - `-f, --format FORMAT`: Output format (console|vcd|csv|json) [default: console]
  - `-m, --max-cycles NUM`: Maximum number of cycles to simulate [default: 1000]
  - `-d, --debug`: Enable debug mode
  - `-v, --verbose`: Enable verbose output
  - `-q, --quiet`: Suppress non-error output
  - `--no-realtime`: Disable real-time output
  - `--breakpoint-state N`: Add state breakpoint
  - `--breakpoint-addr ADDR`: Add address breakpoint (hex)
  - `--step NUM`: Step mode: run NUM cycles at a time
  - `--export FILE`: Export results to FILE
  - `--export-format FORMAT`: Export format (csv|json) [default: csv]
  - `-h, --help`: Show help message

#### Examples

```bash
# Basic simulation with console output
./bin/hotstate_sim -b examples/basic_test/simple_example -s examples/basic_test/stimulus.txt

# Generate VCD waveform for viewing
./bin/hotstate_sim -b examples/basic_test/simple_example -s examples/basic_test/stimulus.txt -f vcd -o trace.vcd

# Interactive debug mode
./bin/hotstate_sim -b examples/basic_test/switches -d

# Debug mode with breakpoints
./bin/hotstate_sim -b examples/basic_test/switches -d --breakpoint-state 1

# Export results to CSV
./bin/hotstate_sim -b examples/basic_test/simple_example -s examples/basic_test/stimulus.txt --export results.csv
```

#### Input Formats

**Stimulus File Format**

The stimulus file defines input values over time:

```
# Cycle, Input1, Input2, Input3, ...
# Comments start with #

# Initial state - all inputs low
0, 0, 0, 0

# Cycle 1 - set first input high
1, 1, 0, 0

# Cycle 2 - set second input high
2, 1, 1, 0
```

**Memory Files**

The simulator expects the following files generated by the C parser:

- `*_vardata.mem`: Variable data storage (one value per line)
- `*_switchdata.mem`: Switch/case jump address tables
- `*_smdata.mem`: State machine microcode instructions (hexadecimal)
- `*_params.vh`: Parameter definitions and bit widths

#### Output Formats

**Console Output**

Real-time display of simulation state:

```
Cycle:      0, Addr: 0x0000, Ready: 1, LHS: 0, Fired: 0, States: 00000000, Outputs: [0x00, 0x00], Inputs: [0x00, 0x00]
Cycle:      1, Addr: 0x0001, Ready: 1, LHS: 1, Fired: 1, States: 00000001, Outputs: [0x01, 0x00], Inputs: [0x01, 0x00]
```

**VCD Output**

Waveform format compatible with GTKWave and other waveform viewers.

**CSV Output**

Tabular data for analysis in spreadsheet applications.

**JSON Output**

Structured data for programmatic analysis.

#### Interactive Debug Mode

When using the `-d` flag, the simulator enters interactive debug mode with comprehensive debugging features.

**Debugger Commands**

- Simulation Control: run, step, continue, pause, reset, quit
- Inspection: state, vars, microcode, memory, stack, signals, watch
- Breakpoints: bp state, bp addr, bp clear, bp list
- Watch: watch var, watch state, watch clear, watch list
- Manual Control: set input, set var, info, stats

### C23 `_BitInt` Support

The parser supports C23 `_BitInt` types with additional bit-indexing feature:

```c
int main() {
    _BitInt(3) x = {1, 0, 1};  // x = 5 (binary 101)
    _BitInt(8) byte = 255;     // 8-bit integer
    
    if (x[1]) {                // Test bit 1 (NOT C23 compatible)
        x[2] = 0;              // Clear bit 2
    }
    
    byte[7] = x[0];            // Copy bit 0 of x to bit 7 of byte
    return 0;
}
```

See `docs/bitint_feature.md` for complete documentation.

### Error Messages

The parser provides detailed error reporting with line and column information:

```bash
$ ./c_parser test_errors.c
Parse Error at line 2, column 14: _BitInt width must be positive
  Token: RPAREN (')')
```

## Project Structure

```
src/                    # Main parser and code generation
├── lexer.h/c              # Lexical analyzer
├── parser.h/c             # Recursive descent parser
├── ast.h/c                # AST node definitions
├── cfg.h/c                # CFG data structures
├── cfg_builder.h/c        # AST to CFG conversion
├── cfg_utils.h/c          # CFG utilities and visualization
├── hw_analyzer.h/c        # Hardware variable analysis
├── cfg_to_microcode.h/c   # CFG to microcode translation
├── microcode_output.c     # Microcode output generation
├── verilog_generator.h/c  # Verilog HDL generation
├── main.c                 # Main program
├── test_cfg.c             # CFG test suite
sim/                    # Hotstate machine simulator
├── src/                   # Simulator source code
│   ├── main.cpp           # Command line interface
│   ├── simulator.cpp      # Core simulator engine
│   ├── hotstate_model.cpp # Hotstate machine implementation
│   ├── memory_loader.cpp  # Memory file parsing
│   ├── stimulus_parser.cpp # Input stimulus handling
│   ├── output_logger.cpp  # Output and trace handling
│   └── utils.cpp          # Common utilities
├── include/               # Header files
├── examples/              # Example test cases
├── bin/                   # Built binaries
├── obj/                   # Object files
└── Makefile              # Build configuration
test/                   # Test C programs and scripts
docs/                   # Documentation
    ├── cfg_ssa_design.md  # Detailed CFG/SSA design
    └── hardware_synthesis.md  # Hardware synthesis documentation
```

## Example

Input C code:
```c
int max(int a, int b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

Generated CFG:
- Entry block evaluates `a > b`
- True branch returns `a`
- False branch returns `b`
- All paths lead to exit block

## Testing

Run all tests:
```bash
# Parser tests
./c_parser test/test_functions_complete.c

# CFG tests with visualization
make test
make graphs
```

## Command Line Options

```bash
./c_parser [OPTIONS] <filename.c>

Options:
  --dot          Generate a DOT file for CFG visualization
  --debug        Enable debug output messages
  --hardware     Analyze hardware constructs (state/input variables)
  --microcode    Generate microcode from CFG
  --microcode-hs Generate hotstate-compatible microcode from the AST
  --verilog      Generate Verilog HDL module
  --testbench    Generate Verilog testbench
  --all-hdl      Generate all HDL files (module, testbench, stimulus, makefile)
```

## Future Work

See `docs/cfg_ssa_design.md` for planned enhancements:
- Static Single Assignment (SSA) intermediate form with phi functions
- Optimization passes (constant propagation, dead code elimination)
- Advanced hardware optimizations (state minimization)
- VHDL HDL generation
- Advanced analyses (dominance, loop detection)

## Developer Information

## Documentation

- `README_CFG.md` - Detailed CFG implementation documentation
- `docs/cfg_ssa_design.md` - Comprehensive design for SSA form and optimizations
- `docs/bitint_feature.md` - Complete `_BitInt` type documentation with examples
- `docs/hardware_synthesis.md` - Hardware synthesis and HDL generation guide
- `sim/README.md` - Hotstate machine simulator documentation

## License

This project is for educational purposes.
